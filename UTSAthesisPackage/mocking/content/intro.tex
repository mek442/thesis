\section{Introduction}
\label{sec:intromock}

In modern software development, testing is a major approach to software quality assurance before a software application is released. Though the main purpose of testing is to reveal errors in the software application itself, in modern software practice, software applications can hardly be executed and tested without any dependencies such as libraries, third-party services, external data, etc. 

To perform testing efficiently and effectively, one significant challenge is to handle various software dependencies properly. It should be noted that testing a software application with all of its dependencies is not always appropriate or even possible. The reason are three folds. First of all, some software dependencies such as web services and databases are very slow when they are invoked. Thus involving such dependencies in testing will slow down the whole testing process, which may be fine for system testing, but not acceptable in unit testing and regression testing which are typically performed whenever a change is committed. Second, in unit testing, the testers should focus on the unit (e.g., functions, classes) to be tested. Involving some unstable dependencies may result in test interference due to bugs in the dependencies, and make it more difficult to identify and fix bugs inside the unit. Third, in large software projects, it is common that software developers develop different modules simultaneously and integrate the modules later. In such cases, it is probable that testing a certain module requires another module that has not been developed yet. Also, when developing frameworks that support call-backs, it is common that the dependencies invoked by the call-backs are not available at the testing phase (the call-backs are supposed to be defined by users of a framework). 

In the practice of testing object-oriented software development process, to resolve the issues brought by software dependencies, mock objects are a typical solution. Primitive mock objects are also known as server stubs, introduced in Binder's book~\cite{binder2000testing} as a code pattern for testing object-oriented systems. Mock objects can be used to replace real software dependencies by simulating the relevant features of software dependencies. Typically, methods of mock objects are designed to return some desired values (either a constant value for all inputs, or different values according to different inputs) when specific input values are given. Furthermore, to guarantee the correct interactions between the software component under test and dependencies, mock objects may check their interactions with the software component under test. For example, a mock email sender object of an email client may check whether the email-sending method is ever invoked by the email client and whether the arguments passed into the mock object are in correct format. 

Recently, to facilitate developers in developing mock objects, a number of mocking frameworks (e.g., Mockito, EasyMock) have been developed. These mocking frameworks provide APIs for creating new mock objects, setting return values of methods in the mock objects, and checking interactions between the component under test and the mock objects. Along with the usage of mock objects and mocking frameworks, there are also  many debates among software developers and testers on their usages. For example, some developers argue that mock objects should be used whenever a dependency is invoked because involving real dependencies may result in bug interference, but other developers do not agree because involving mock objects will also bring in a lot of overhead in test execution and maintenance. Also, developers debate on whether mocking frameworks should be used for all mock objects, and what features of mocking frameworks are most useful. 

Despite the development of various mocking frameworks, and debates about usage of mock objects and mocking frameworks, there are very few academic empirical studies to observe and understand how mocking frameworks are used in software testing practice. In this paper, we present an empirical study to fill this blank area. In our study, we analyze the usage of mocking frameworks in 5,000 open source software projects from GitHub\footnote{GitHub: http://github.com}. Specifically, we studied the popularity of mocking frameworks in the testing of open source software projects and how developers of open-source software projects are using the frameworks. Our study finds a substantial usage of mocking frameworks and mock objects among open source Java software projects, but software testers usually mock only a small number of software dependencies. We also find that the unique features of certain mocking framework are frequently used, and there are more mocking of source code classes than mocking of library classes. 
 
The main contributions of this paper are: 
\begin{itemize}
\item We carried out a large scale empirical study on more than 5,000 open source software projects from GitHub. 
\item We discover a number of interesting facts about the usage status of mocking frameworks, including their popularity, most frequently used features, and the characteristics of mocked objects.
\end{itemize}
 
The rest of this paper is organized as follows. In Section~\ref{sec:backgroundmock}, we introduce some background knowledge about the difference and commonality of four of the most popular mocking frameworks. In Section~\ref{sec:designmock} and Section~\ref{sec:studymock}, we present the design details, and the study results of our empirical study, respectively. Before we conclude in Section~\ref{sec:concludemock}, we introduce some related research efforts in Section~\ref{sec:relatedmock}.
